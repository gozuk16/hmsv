// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.23.0
// source: query.sql

package queries

import (
	"context"
)

const insertCpuDownsampledData = `-- name: InsertCpuDownsampledData :exec
INSERT INTO cpu_downsampled (
	timestamp,
	avg_cpu_usage,
	max_cpu_usage
) VALUES (
	?, ?, ?
)
`

type InsertCpuDownsampledDataParams struct {
	Timestamp   string
	AvgCpuUsage float64
	MaxCpuUsage float64
}

func (q *Queries) InsertCpuDownsampledData(ctx context.Context, arg InsertCpuDownsampledDataParams) error {
	_, err := q.db.ExecContext(ctx, insertCpuDownsampledData, arg.Timestamp, arg.AvgCpuUsage, arg.MaxCpuUsage)
	return err
}

const insertCpuOriginalData = `-- name: InsertCpuOriginalData :exec
INSERT INTO cpu_original (
	timestamp,
	cpu_usage
) VALUES (
	?, ?
)
`

type InsertCpuOriginalDataParams struct {
	Timestamp string
	CpuUsage  float64
}

func (q *Queries) InsertCpuOriginalData(ctx context.Context, arg InsertCpuOriginalDataParams) error {
	_, err := q.db.ExecContext(ctx, insertCpuOriginalData, arg.Timestamp, arg.CpuUsage)
	return err
}

const selectCpuDownsamplingData = `-- name: SelectCpuDownsamplingData :many
SELECT
	CAST(strftime('%Y-%m-%d %H:%M:%S', datetime((strftime('%s', timestamp) / ?1) * ?1, 'unixepoch')) AS TEXT) as dstimestamp,
	CAST(AVG(cpu_usage) AS REAL) as ave_cpu_usage,
	CAST(MAX(cpu_usage) AS REAL) as max_cpu_usage
FROM
	cpu_original
GROUP BY dstimestamp
ORDER BY dstimestamp
`

type SelectCpuDownsamplingDataRow struct {
	Dstimestamp string
	AveCpuUsage float64
	MaxCpuUsage float64
}

func (q *Queries) SelectCpuDownsamplingData(ctx context.Context, duration string) ([]SelectCpuDownsamplingDataRow, error) {
	rows, err := q.db.QueryContext(ctx, selectCpuDownsamplingData, duration)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SelectCpuDownsamplingDataRow
	for rows.Next() {
		var i SelectCpuDownsamplingDataRow
		if err := rows.Scan(&i.Dstimestamp, &i.AveCpuUsage, &i.MaxCpuUsage); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
